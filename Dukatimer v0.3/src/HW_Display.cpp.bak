/* HW_Display.cpp - Clean Version
   Kümmert sich NUR um LCD und Nextion Updates.
   Keine Hardware-Steuerung (Relais/LEDs) hier!

   Design:
   - Verwendet `DisplayManager` zur queued Ausgabe an Nextion (verhindert Flooding)
   - Nutzt lokale Cache-Variablen, damit nur geänderte Werte gesendet werden
   - smartLCD synchronisiert 20x4 LCD und Nextion-Overlay; Overlay hat Priorität
   - Display-Updates sind kurz und nicht-blockierend; lange Operationen gehören in andere Module
*/

#include <Arduino.h>
#include <math.h>
#include "Globals.h"
#include "Config.h"

#include "DisplayManager.h"

// =============================================================================
// CACHE VARIABLEN (Damit wir nicht unnötig senden)
// =============================================================================
static int lastMode = -1;
static double lastTimeSoft = UNSET_TIME;
static double lastTimeHard = UNSET_TIME;
static double lastTimeBW   = UNSET_TIME;
static double lastGrade    = UNSET_TIME;
static double lastBurn     = DEFAULT_LAST_BURN;

// LCD Cache
static String lastL1 = "";
static String lastL2 = "";

// Status Cache für Icons
static bool lastIconFocus = false;
static bool lastIconSafe  = false;
static bool lastIconTimer = false;

// --- Nextion key / local UI toggles (file-scope) ---
static char nextionKeyBuf = 0; // virtual key buffer for getNextionKey()
static bool focusOn = false;  // toggled by bFocus
static bool safeOn = false;   // toggled by bSafe

// =============================================================================
// INITIALISIERUNG
// =============================================================================

void initDisplays() {
  Serial.println("initDisplays: START");
  
  // 1. Nextion via DisplayManager
  Serial.println("DM_init()...");
  DM_init();
  #ifdef DEBUG_ENABLED
  DM_setDebug(true);
  #endif
  delay(100);
  Serial.println("initDisplays: DM OK");

  // 2. LCD Start - nur wenn LCD OK
  if (lcdOK) {
    Serial.println("LCD setup...");
    lcd.setRGB(255, 255, 255);
    lcd.setCursor(0, 0);
    lcd.print("Dukatimer v0.3");
    lcd.setCursor(0, 1);
    lcd.print("System Ready");
    Serial.println("LCD setup OK");
  }

  delay(500);
  
  // 3. Erste Info anzeigen (nur LCD - Nextion manuell später)
  Serial.println("triggerInfo()...");
  triggerInfo();
  
  Serial.println("initDisplays: DONE");
}


// =============================================================================
// UI UPDATE LOGIK
// =============================================================================

// Nextion UI - SIMPLIFIED (nur Debug-Logging, keine automatischen Updates)
void updateNextionUI(bool force) {
  // Nextion UI completely disabled - all updates must be done manually via DM_* functions
  // This allows for complete re-design of the Nextion interface
  
  // Just process DM_loop to receive touch events
  DM_loop();
}

// getNextionKey: returns and clears any virtual key set by Nextion touch handlers
char getNextionKey() {
  char k = nextionKeyBuf;
  nextionKeyBuf = 0;
  return k;
}

// =============================================================================
// LCD UPDATE LOGIK
// =============================================================================

// Setzt den Text auf dem 20x4 LCD (C-String Optimized Version)
void smartLCD(String l1, String l2) {
  if (!lcdOK) return;

  // 1. FEHLER-ANZEIGE PRIORITÄT (Logik bleibt identisch)
  bool showSoftAbort = softAbortActive && (millis() < softAbortUntilMs);
  if (softAbortActive && !showSoftAbort) {
    softAbortActive = false;
  }

  if (showSoftAbort) {
    lcd.setRGB(255, 60, 0); // Warnfarbe (Soft Abort)
    l1 = "SOFT ABORT";
    l2 = "SENSOR LOST";
  } else if (lastSystemError != ERR_NONE) {
    lcd.setRGB(255, 100, 0); // Orange Warnfarbe
    if (millis() % 2000 < 1000) { 
      l1 = "!!! ERROR: " + String((int)lastSystemError);
    }
  } else if (starttime != 0) {
    lcd.setRGB(0, 0, 0); // Display aus während Belichtung
  } else if (digitalRead(PIN_SW_SAFE) == LOW) {
    lcd.setRGB(255, 0, 0); // Rotlicht-Modus
  } else {
    lcd.setRGB(255, 255, 255); // Standby Weiß
  }

  // 2. C-STRING FORMATIERUNG (Die Lösung des Problems)
  // Wir nutzen Puffer für 16 Zeichen + 1 Null-Terminator
  char buf1[17];
  char buf2[17];

  // snprintf Formatierung:
  // %-16.16s bedeutet:
  // - : Linksbündig (Padding mit Leerzeichen rechts)
  // 16: Mindestbreite 16 Zeichen (füllt auf)
  // .16: Maximallänge 16 Zeichen (schneidet ab)
  snprintf(buf1, sizeof(buf1), "%-16.16s", l1.c_str());
  snprintf(buf2, sizeof(buf2), "%-16.16s", l2.c_str());

  // Umwandlung zurück in String für den Vergleich und die Ausgabe
  String l1out = String(buf1);
  String l2out = String(buf2);

  // 3. HARDWARE UPDATE (Nur bei Änderung)
  if (l1out != lastL1) { 
    lcd.setCursor(0, 0); 
    lcd.print(l1out); 
    lastL1 = l1out; 
  }
  
  if (l2out != lastL2) { 
    lcd.setCursor(0, 1); 
    lcd.print(l2out); 
    lastL2 = l2out; 
  }
}

// Formatiert die aktuellen Werte für das LCD
void triggerInfo() {
  String L1 = "";
  String L2 = "";
  
  if (currentMode == MODE_BW) {
      L1 = "BW Mode";
      L2 = "T:" + String(time_bw, 1) + "s  G:" + String(grade_bw, 1);
      
      // Burn Anzeige überschreibt Zeile 1 falls aktiv
      if (burnEv != 0.0) {
          String s = (burnEv > 0) ? "+" : "";
          L1 = "BURN " + s + String(burnEv, 1) + "EV";
      }
  }
  else if (currentMode == MODE_SG) {
      L1 = "Soft: " + String(time_soft, 1) + "s";
      L2 = "Hard: " + String(time_hard, 1) + "s";
  }
  
  smartLCD(L1.c_str(), L2.c_str());
}